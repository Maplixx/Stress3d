<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>S9 Meltdown - Volumetric</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: monospace; }
        
        #ui-container {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(20, 0, 0, 0.9);
            border-top: 3px solid red;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        #stats-box {
            position: absolute; top: 10px; left: 10px;
            background: #000; border: 1px solid #0f0;
            padding: 5px 10px; font-size: 20px; color: #0f0;
            font-weight: bold; z-index: 10;
        }

        input[type=range] { width: 100%; height: 30px; accent-color: red; }
        
        .label { display: flex; justify-content: space-between; font-size: 1.2em; margin-bottom: 10px; }
        .warning { color: red; text-align: center; font-size: 0.9em; margin-top: 5px; }
    </style>
</head>
<body>

    <div id="stats-box">FPS: <span id="fps">0</span></div>

    <div id="ui-container">
        <div class="label">
            <span>Resolução (Peso):</span>
            <span id="res-text" style="color:orange">1.0x</span>
        </div>
        <input type="range" id="res-slider" min="0.5" max="4.0" step="0.1" value="1.0">
        <div class="warning">⚠️ Cuidado: 2.0x já deve travar. 4.0x é tela preta garantida por falta de RAM.</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let renderer, scene, camera, material, mesh;
        let startTime = Date.now();
        const fpsElem = document.getElementById('fps');
        let frameCount = 0;
        let lastTime = performance.now();

        // SHADER DE VOLUMETRIA (NEBLINA)
        // Isso é pesado porque ele executa loops longos para cada pixel visível.
        const fragmentShader = `
            precision highp float;
            uniform float iTime;
            uniform vec2 iResolution;

            // Função de rotação
            mat2 rot(float a) {
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c);
            }

            // Função de Ruído Pseudo-Aleatório (Pesada se chamada muitas vezes)
            float hash(vec3 p) {
                p = fract(p * 0.3183099 + .1);
                p *= 17.0;
                return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
            }

            // O Mapa do Mundo (Túnel)
            float map(vec3 p) {
                vec3 q = p;
                q.xy *= rot(p.z * 0.1); // Torce o túnel
                // Cria um túnel infinito usando repetição
                float tunnel = length(q.xy) - 3.0; 
                
                // Adiciona rugosidade nas paredes (Ruído)
                // Usar sin/cos aqui obriga a GPU a fazer trigonometria para cada passo
                float noise = sin(p.z*2.0)*cos(p.x*2.0) + sin(p.y)*0.5;
                
                return min(tunnel + noise, p.y + 2.0); // Chão + Túnel
            }

            void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
                
                // Câmera voando rápido
                vec3 ro = vec3(0.0, 0.0, iTime * 4.0);
                vec3 rd = normalize(vec3(uv, 1.0));
                
                // Gira a câmera um pouco
                rd.xy *= rot(iTime * 0.2);

                vec3 col = vec3(0.0);
                float t = 0.0;
                
                // --- O PESADELO DA GPU: VOLUMETRIA ---
                // Em vez de procurar uma superfície, vamos somar "luz" ao longo do caminho.
                // 150 Passos fixos. A GPU NÃO PODE otimizar isso. Ela tem que rodar os 150.
                for(int i = 0; i < 150; i++) {
                    vec3 p = ro + rd * t;
                    float d = map(p); // Distância para a parede
                    
                    // Truque para criar "brilho" volumétrico
                    // Se passarmos PERTO da parede (d < 1.0), adicionamos cor.
                    float density = 0.1 / (abs(d) + 0.01); // Quanto mais perto, mais forte
                    
                    // Cor baseada na posição (psicodélico)
                    vec3 sphereCol = 0.5 + 0.5*cos(iTime + p.z*0.1 + vec3(0,2,4));
                    
                    col += sphereCol * density * 0.02; // Acumula a cor
                    
                    // Avança um pouco. Se avançar muito rápido (t += d), perde a neblina.
                    // Avançar fixo (0.15) força muitos cálculos.
                    t += max(d * 0.3, 0.15); 
                    
                    if(t > 40.0) break; // Longe demais
                }

                // Ajuste de contraste final
                col = pow(col, vec3(1.2));
                
                fragColor = vec4(col, 1.0);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        const vertexShader = `
            void main() {
                gl_Position = vec4( position, 1.0 );
            }
        `;

        function init() {
            // Setup básico do Three.js para renderizar um quadrado na tela toda
            camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
            scene = new THREE.Scene();
            const geometry = new THREE.PlaneGeometry( 2, 2 );

            material = new THREE.ShaderMaterial( {
                uniforms: {
                    iTime: { value: 0 },
                    iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                depthWrite: false,
                depthTest: false
            } );

            mesh = new THREE.Mesh( geometry, material );
            scene.add( mesh );

            // Cria o renderizador
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                precision: "highp"
            });
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            // Listeners
            window.addEventListener( 'resize', onWindowResize );
            
            // Slider Logic
            const slider = document.getElementById('res-slider');
            const resText = document.getElementById('res-text');
            
            slider.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                renderer.setPixelRatio(val);
                
                // Atualiza o Uniform também para o shader saber o tamanho novo
                material.uniforms.iResolution.value.set(
                    window.innerWidth * val,
                    window.innerHeight * val
                );
                
                let status = "(Leve)";
                if(val > 1.5) status = "(Pesado)";
                if(val > 2.5) status = "(INSANO)";
                
                resText.innerText = val.toFixed(1) + "x " + status;
            });

            animate();
        }

        function onWindowResize() {
            const val = parseFloat(document.getElementById('res-slider').value);
            renderer.setSize( window.innerWidth, window.innerHeight );
            material.uniforms.iResolution.value.set(
                window.innerWidth * val,
                window.innerHeight * val
            );
        }

        function animate() {
            requestAnimationFrame( animate );

            // Atualiza o tempo
            material.uniforms.iTime.value = (Date.now() - startTime) * 0.001;

            renderer.render( scene, camera );

            // Contador FPS
            const now = performance.now();
            frameCount++;
            if (now - lastTime >= 1000) {
                fpsElem.innerText = frameCount;
                if(frameCount < 15) fpsElem.style.color = "red";
                else if(frameCount < 30) fpsElem.style.color = "orange";
                else fpsElem.style.color = "#0f0";
                
                frameCount = 0;
                lastTime = now;
            }
        }

        init();
    </script>
</body>
</html>
