<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Moto G85 Killer - Nuclear Shader</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: monospace; }
        #info {
            position: absolute; top: 10px; left: 10px;
            background: rgba(50,0,0,0.8); padding: 10px;
            border: 2px solid red; pointer-events: none;
        }
        #fps { font-size: 24px; color: red; font-weight: bold; }
        #res-control {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 85%; text-align: center;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px;
            border: 1px solid red;
        }
        input[type=range] { width: 100%; accent-color: red; margin: 10px 0; }
    </style>
</head>
<body>
    <div id="info">
        FPS: <span id="fps">Calculando...</span><br>
        <span style="font-size:12px; color:#faa">Shader: Raymarching Nuclear</span>
    </div>

    <div id="res-control">
        <label style="color:red; font-weight:bold;">Nível de Destruição (Resolução)</label>
        <input type="range" id="pixel-ratio" min="1.0" max="3.0" step="0.1" value="1.5">
        <div id="res-val" style="color:red; font-weight:bold; font-size:1.2em;">1.5x (Pesado)</div>
        <div style="font-size:11px; color:#ccc; margin-top:5px;">Coloque em 3.0x para testar o Moto G85.</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let camera, scene, renderer, material;
        let startTime = Date.now();
        const fpsElem = document.getElementById('fps');
        let frameCount = 0;
        let lastTime = performance.now();

        // --- O SHADER CORRIGIDO E MAIS PESADO ---
        const fragmentShader = `
            precision highp float; // Força alta precisão (mais pesado)
            uniform float iTime;
            uniform vec2 iResolution;

            mat2 rot(float a) {
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c);
            }

            // Função do Fractal (Mais complexa agora)
            float map(vec3 p) {
                vec3 q = p;
                // Repetição espacial para encher a tela
                p.xy = mod(p.xy, 4.0) - 2.0;
                p.z = mod(p.z, 8.0) - 4.0;

                p.xy *= rot(iTime * 0.2 + p.z * 0.1);

                float d = 1e5;
                float s = 1.0;
                // AUMENTEI DE 6 PARA 10 ITERAÇÕES (Multiplica o peso do cálculo)
                for(int i = 0; i < 10; i++) {
                    p = abs(p) - vec3(0.4, 0.3, 0.2 + sin(iTime*0.1)*0.1);
                    float r = dot(p, p);
                    // Adicionei mais complexidade na deformação
                    float k = 1.8 / min(r, 1.5); 
                    p *= k;
                    s *= k;
                    d = min(d, length(p.xz) / s);
                }
                return d - 0.01;
            }

            void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;

                // Câmera corrigida, avançando no túnel
                vec3 ro = vec3(0.0, 0.0, iTime * 2.0); 
                vec3 rd = normalize(vec3(uv, 1.5)); // FOV menor para focar

                float t = 0.0;
                float d = 0.0;
                int i;
                // AUMENTEI DE 80 PARA 200 PASSOS POR PIXEL (O dobro do peso)
                for(i = 0; i < 200; i++) {
                    d = map(ro + rd * t);
                    if(d < 0.001 || t > 50.0) break;
                    t += d * 0.7; // Passos menores para mais qualidade e peso
                }

                // Cor baseada na distância (t) e iterações (i)
                vec3 col = vec3(0.0);
                if(t < 50.0) {
                    // Cor do objeto fractal
                    float glow = float(i) / 200.0;
                    col = vec3(1.0, 0.5, 0.1) * glow * glow * 5.0;
                    col += vec3(0.1, 0.3, 1.0) * (1.0/t);
                } else {
                    // Cor de fundo (para não ficar tudo branco se errar)
                    col = vec3(0.02, 0.02, 0.05) * (uv.y + 0.5);
                }

                // Fumaça/Fog para dar volume
                col = mix(col, vec3(0.0,0.0,0.1), 1.0 - exp(-0.05*t*t));

                fragColor = vec4(col, 1.0);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        const vertexShader = `
            void main() {
                gl_Position = vec4( position, 1.0 );
            }
        `;

        function init() {
            camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
            scene = new THREE.Scene();
            const geometry = new THREE.PlaneGeometry( 2, 2 );

            material = new THREE.ShaderMaterial( {
                uniforms: {
                    iTime: { value: 0 },
                    iResolution: { value: new THREE.Vector2() }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader
            } );

            scene.add( new THREE.Mesh( geometry, material ) );

            // Renderizador com contexto WebGL2 se disponível para mais poder de travamento
            try {
                renderer = new THREE.WebGLRenderer({ context: document.createElement('canvas').getContext('webgl2') });
            } catch(e) {
                renderer = new THREE.WebGLRenderer();
            }
            
            document.body.appendChild( renderer.domElement );
            
            // Valor inicial do slider
            let initialRes = parseFloat(document.getElementById('pixel-ratio').value);
            renderer.setPixelRatio(initialRes);
            updateResolutionUniform(initialRes);

            window.addEventListener( 'resize', onWindowResize );

            document.getElementById('pixel-ratio').addEventListener('input', function(e) {
                let val = parseFloat(e.target.value);
                renderer.setPixelRatio(val);
                document.getElementById('res-val').innerText = val.toFixed(1) + "x " + (val >= 2.5 ? "(NUCLEAR)" : "(Pesado)");
                updateResolutionUniform(val);
            });
            
            animate();
        }

        function updateResolutionUniform(pixelRatio) {
            renderer.setSize( window.innerWidth, window.innerHeight );
            material.uniforms.iResolution.value.set( 
                window.innerWidth * pixelRatio, 
                window.innerHeight * pixelRatio 
            );
        }

        function onWindowResize() {
            updateResolutionUniform(renderer.getPixelRatio());
        }

        function animate() {
            requestAnimationFrame( animate );
            material.uniforms.iTime.value = (Date.now() - startTime) * 0.001;
            renderer.render( scene, camera );
            updateFPS();
        }

        function updateFPS() {
            const now = performance.now();
            frameCount++;
            if (now - lastTime >= 1000) {
                fpsElem.innerText = frameCount;
                frameCount = 0;
                lastTime = now;
            }
        }

        init();
    </script>
</body>
</html>
