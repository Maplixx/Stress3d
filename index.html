<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>S9 Raymarching Killer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: monospace; }
        #info {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.8); padding: 10px;
            border: 1px solid red; pointer-events: none;
        }
        #fps { font-size: 24px; color: #0f0; font-weight: bold; }
        #res-control {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 80%; text-align: center;
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px;
        }
        input[type=range] { width: 100%; accent-color: red; }
    </style>
</head>
<body>
    <div id="info">
        FPS: <span id="fps">0</span><br>
        <span style="font-size:12px; color:#aaa">Shader: Raymarching Fractal</span>
    </div>

    <div id="res-control">
        <label>Resolução de Renderização (Peso)</label>
        <input type="range" id="pixel-ratio" min="0.5" max="3.0" step="0.1" value="1.5">
        <div id="res-val" style="color:red; font-weight:bold;">1.5x (Pesado)</div>
        <div style="font-size:10px; color:#ccc; margin-top:5px;">Arraste para a direita para 3.0x se quiser travar tudo.</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONFIGURAÇÃO ---
        let camera, scene, renderer, material;
        let startTime = Date.now();
        const fpsElem = document.getElementById('fps');
        let frameCount = 0;
        let lastTime = performance.now();

        // O SHADER (A Mágica do Mal)
        // Isso aqui roda na GPU para CADA PIXEL da tela.
        // É um fractal Mandelbulb misturado com repetição espacial.
        const fragmentShader = `
            uniform float iTime;
            uniform vec2 iResolution;

            // Função de rotação
            mat2 rot(float a) {
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c);
            }

            // Função de Distância (SDF) - O Fractal
            float map(vec3 p) {
                vec3 q = p;
                
                // Repetição infinita no espaço (Deixa pesado pois tem "coisa" em todo lugar)
                vec3 rep = vec3(4.0);
                p = mod(p + rep*0.5, rep) - rep*0.5;

                // Deformação baseada no tempo
                p.xy *= rot(iTime * 0.5);
                p.yz *= rot(iTime * 0.3);

                // Forma Fractal simples (Iterações pesam)
                float d = 1000.0;
                float s = 1.0;
                for(int i = 0; i < 6; i++) { // Aumentar esse loop mata a GPU
                    p = abs(p) - vec3(0.5, 0.4, 0.3); // Dobra o espaço
                    float r = dot(p, p);
                    if (r < 2.0) p = p * (1.5 / r); // Scale
                    s *= 1.3;
                    d = min(d, length(p) / s); // Salva a menor distância
                }
                
                // Retorna uma esfera distorcida pelo fractal
                return length(p) - 0.15;
            }

            // Raymarching: Lança um raio para cada pixel e anda até bater em algo
            void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;

                vec3 ro = vec3(0.0, 0.0, -3.0 + iTime * 2.0); // Câmera andando
                vec3 rd = normalize(vec3(uv, 1.0)); // Direção do raio

                float t = 0.0;
                float d = 0.0;
                vec3 p;
                
                // Loop principal do Raymarching
                // Quanto mais iterações, mais longe ele vê e mais PESADO fica.
                // 80 passos por pixel é muito para mobile em full screen.
                int i;
                for(i = 0; i < 80; i++) {
                    p = ro + rd * t;
                    d = map(p); // Calcula a distância para o fractal
                    if(d < 0.001 || t > 100.0) break; // Bateu ou foi muito longe
                    t += d;
                }

                // Cor baseada nas iterações (Glow)
                vec3 col = vec3(float(i) / 80.0);
                col = pow(col, vec3(2.0)) * vec3(1.0, 0.5, 0.2); // Cor de fogo
                
                // Adiciona um pouco de fog
                col += vec3(0.1, 0.2, 0.4) * (t * 0.05);

                fragColor = vec4(col, 1.0);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        const vertexShader = `
            void main() {
                gl_Position = vec4( position, 1.0 );
            }
        `;

        function init() {
            const container = document.body;

            // Câmera ortográfica (2D) pois só queremos desenhar um quadrado na tela toda
            camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
            scene = new THREE.Scene();

            // Geometria que cobre a tela inteira
            const geometry = new THREE.PlaneGeometry( 2, 2 );

            // Passando o tempo e a resolução para o shader
            const uniforms = {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            };

            material = new THREE.ShaderMaterial( {
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader
            } );

            const mesh = new THREE.Mesh( geometry, material );
            scene.add( mesh );

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( 1.5 ); // Começa pesado (1.5x a resolução da tela)
            container.appendChild( renderer.domElement );

            onWindowResize();
            window.addEventListener( 'resize', onWindowResize );

            // Controle do Slider
            document.getElementById('pixel-ratio').addEventListener('input', function(e) {
                let val = parseFloat(e.target.value);
                renderer.setPixelRatio(val);
                document.getElementById('res-val').innerText = val + "x " + (val > 2.0 ? "(INSANO)" : "(Pesado)");
                
                // Atualiza o tamanho para aplicar o novo pixel ratio
                renderer.setSize( window.innerWidth, window.innerHeight );
                material.uniforms.iResolution.value.set(
                    window.innerWidth * val, 
                    window.innerHeight * val
                );
            });
            
            animate();
        }

        function onWindowResize() {
            const val = parseFloat(document.getElementById('pixel-ratio').value);
            renderer.setSize( window.innerWidth, window.innerHeight );
            // Atualiza a resolução enviada para o shader
            material.uniforms.iResolution.value.set( 
                window.innerWidth * val, 
                window.innerHeight * val 
            );
        }

        function animate() {
            requestAnimationFrame( animate );

            // Atualiza o tempo do shader
            material.uniforms.iTime.value = (Date.now() - startTime) * 0.001;

            renderer.render( scene, camera );

            // Contador FPS
            const now = performance.now();
            frameCount++;
            if (now - lastTime >= 1000) {
                fpsElem.innerText = frameCount;
                fpsElem.style.color = frameCount < 20 ? 'red' : (frameCount < 50 ? 'orange' : '#0f0');
                frameCount = 0;
                lastTime = now;
            }
        }

        init();
    </script>
</body>
</html>
